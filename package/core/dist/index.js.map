{"version":3,"sources":["../src/func/index.ts"],"sourcesContent":["import type {\n    Select,\n    Result,\n    Contract,\n    UnionToIntersection,\n    Input,\n    Term,\n    ArraySelect,\n} from \"../type\";\n\n/**\n * Applies selection criteria to transform data according to the specified selection rules\n * - Handles arrays with pagination (offset/length) and recursive item selection\n * - Supports shallow selection (*) that excludes nested objects\n * - Supports deep selection (**) that returns complete data\n * - Performs selective field extraction for object selections\n * - Returns scalars unchanged\n * @template TBase - The base data type to select from\n * @template TSelect - The selection criteria to apply\n * @param base - The source data to transform\n * @param select - The selection configuration\n * @returns Transformed data matching the selection criteria\n */\nexport const applySelection = <TBase, TSelect extends Select<TBase>>(\n    base: TBase,\n    select: TSelect,\n): Result<TBase, TSelect> => {\n    if (base === null || base === undefined || typeof base !== \"object\") {\n        return base as Result<TBase, TSelect>;\n    }\n\n    if (Array.isArray(base)) {\n        const arraySelect = select as ArraySelect<any>;\n        if (!Array.isArray(arraySelect)) {\n            return base as Result<TBase, TSelect>;\n        }\n\n        const [itemSelect, options] = arraySelect;\n        const offset = options?.offset || 0;\n        const length = options?.length;\n\n        const slicedArray =\n            length !== undefined\n                ? base.slice(offset, offset + length)\n                : base.slice(offset);\n\n        return slicedArray.map((item) =>\n            applySelection(item, itemSelect),\n        ) as Result<TBase, TSelect>;\n    }\n\n    if (select === \"*\") {\n        const result: any = {};\n        for (const key in base) {\n            if (base.hasOwnProperty(key)) {\n                const value = (base as any)[key];\n                if (\n                    value === null ||\n                    value === undefined ||\n                    typeof value !== \"object\"\n                ) {\n                    result[key] = value;\n                }\n            }\n        }\n        return result as Result<TBase, TSelect>;\n    }\n\n    if (select === \"**\") {\n        return base as Result<TBase, TSelect>;\n    }\n\n    if (typeof select === \"object\" && !Array.isArray(select)) {\n        const result: any = {};\n        const selectObj = select as Record<string, any>;\n\n        for (const key in selectObj) {\n            if (selectObj.hasOwnProperty(key) && key in base) {\n                const selectValue = selectObj[key];\n                const baseValue = (base as any)[key];\n\n                if (selectValue === true) {\n                    result[key] = baseValue;\n                } else {\n                    result[key] = applySelection(baseValue, selectValue);\n                }\n            }\n        }\n        return result as Result<TBase, TSelect>;\n    }\n\n    return base as Result<TBase, TSelect>;\n};\n\n/**\n * Creates a unified contract function from multiple Term operations\n * The resulting function can dispatch to any operation in the contract based on the operation name\n * Ensures type safety by validating that contract keys match their Term operation types\n * @template TContract - Object mapping operation names to Term implementations\n * @param contract - The contract object containing all available operations\n * @returns A unified function that can execute any operation from the contract\n * @throws Error when attempting to call an unknown operation\n */\nexport const createContract = <\n    const TContract extends { [key: string]: Term<any, any, any, any> },\n>(\n    contract: TContract & Contract<TContract>,\n): UnionToIntersection<TContract[keyof TContract]> =>\n    ((input: Input<any, any, any, any>) => {\n        const term = contract[input[0]];\n        if (term === undefined) {\n            throw new Error(`Unknown operation: ${input[0]}`);\n        }\n        return term(...input);\n    }) as any;\n"],"mappings":";AAuBO,IAAM,iBAAiB,CAC1B,MACA,WACyB;AACzB,MAAI,SAAS,QAAQ,SAAS,UAAa,OAAO,SAAS,UAAU;AACjE,WAAO;AAAA,EACX;AAEA,MAAI,MAAM,QAAQ,IAAI,GAAG;AACrB,UAAM,cAAc;AACpB,QAAI,CAAC,MAAM,QAAQ,WAAW,GAAG;AAC7B,aAAO;AAAA,IACX;AAEA,UAAM,CAAC,YAAY,OAAO,IAAI;AAC9B,UAAM,SAAS,SAAS,UAAU;AAClC,UAAM,SAAS,SAAS;AAExB,UAAM,cACF,WAAW,SACL,KAAK,MAAM,QAAQ,SAAS,MAAM,IAClC,KAAK,MAAM,MAAM;AAE3B,WAAO,YAAY;AAAA,MAAI,CAAC,SACpB,eAAe,MAAM,UAAU;AAAA,IACnC;AAAA,EACJ;AAEA,MAAI,WAAW,KAAK;AAChB,UAAM,SAAc,CAAC;AACrB,eAAW,OAAO,MAAM;AACpB,UAAI,KAAK,eAAe,GAAG,GAAG;AAC1B,cAAM,QAAS,KAAa,GAAG;AAC/B,YACI,UAAU,QACV,UAAU,UACV,OAAO,UAAU,UACnB;AACE,iBAAO,GAAG,IAAI;AAAA,QAClB;AAAA,MACJ;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAEA,MAAI,WAAW,MAAM;AACjB,WAAO;AAAA,EACX;AAEA,MAAI,OAAO,WAAW,YAAY,CAAC,MAAM,QAAQ,MAAM,GAAG;AACtD,UAAM,SAAc,CAAC;AACrB,UAAM,YAAY;AAElB,eAAW,OAAO,WAAW;AACzB,UAAI,UAAU,eAAe,GAAG,KAAK,OAAO,MAAM;AAC9C,cAAM,cAAc,UAAU,GAAG;AACjC,cAAM,YAAa,KAAa,GAAG;AAEnC,YAAI,gBAAgB,MAAM;AACtB,iBAAO,GAAG,IAAI;AAAA,QAClB,OAAO;AACH,iBAAO,GAAG,IAAI,eAAe,WAAW,WAAW;AAAA,QACvD;AAAA,MACJ;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAEA,SAAO;AACX;AAWO,IAAM,iBAAiB,CAG1B,aAEC,CAAC,UAAqC;AACnC,QAAM,OAAO,SAAS,MAAM,CAAC,CAAC;AAC9B,MAAI,SAAS,QAAW;AACpB,UAAM,IAAI,MAAM,sBAAsB,MAAM,CAAC,CAAC,EAAE;AAAA,EACpD;AACA,SAAO,KAAK,GAAG,KAAK;AACxB;","names":[]}